1:jdk1.5之前是thread 和 Runable，之后又callable
2；futureTask，volite修饰符， 
crtl+shift+B 全选  回车 查看继承结构图
3：多线程的目的 就是最大限度的利用cpu资源；当某一线程不需要占用cpu，而只和io等资源打交道时，让需要占用cpu的线程有机会获取cpu资源；
4：线程的实现方式：Runable，Thread，Callable
5：线程的生命周期：a:初始化:new
                              b:就绪：调用.start();这时候需要等待jvm的调度，不一定会马上执行；
                              c:运行：执行 run（） 方法；
                                                 c1：等待  wait 
                                                 c2：睡眠：sleep
                                                 c3：阻塞：blocked/  同步锁 
                              d：死亡，run执行完毕，调用stop，异常抛出 ，都会导致线程死亡；
6：让线程有序执行：join 方法；join方法可以阻塞主线程，当本线程调用完毕后继续执行；
7：wating 会释放对象锁，进入等待状态，当被唤醒时，会马上进入准备状态，获取对象锁，
8：sleep 不会释放对象锁，一直占有，知道时间结束；
9：yeild:使用该方法有机会释放cpu资源，暗示cpu降低对该资源的调度，具体还要看cpu的调度；
10：futureTask 类里面的线程状态 0-6、
11：futrueTask 实现了runnable，和callable，构造方法可以传入这两个接口的实现类，本身实现类run方法，启动一个线程执行就好
    改方法的get方法实现了阻塞队列，可以获取线程的返回值； task.get();
12: volatile 保证修饰的变量的可见性
13：可见性（所有线程都能看到一个公共变量）；原子性（基本数据类型读取，要么成功，要么失败），有序性（保证执行顺序）
14：在多核cpu计算中，例如i= i+1；会将主存的数据读取到高速缓冲区，然后修改后赋值写会主存中，假设i=0；两个线程来执行
    那么结果是2；但是由于cpu处理速度非常快，导致在读取的i的时候两个线程读取到的都是0，导致最终结果是1；共享变量不一致的问题
15：java代码值cpu执行时，会把两个依赖的进行有序执行，不影响的分开执行提升效率，保证最终结果一致，但不保证执行顺讯一定和代码写的一致
16：synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性
17：volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作
18：锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作
19：程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作
20：传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C
21：线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作
22：线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
23：线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行
24：对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始
25：为什么要用线程池？
26：线程越多不代表效率越高；线程越多会消耗很多时间在cpu分片与上下文切换上；
27：java中有几种线程池？普通线程池，定时线程池